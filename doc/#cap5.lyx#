#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass classicthesis
\begin_preamble
\usepackage[spanish,es-lcroman,es-tabla]{babel}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Herramientas [4-5 Hojas] Implementación
\end_layout

\begin_layout Standard
Ya contamos con todas las bases teóricas para poder empezar a buscar (y
 con suerte, encontrar) simetrías en 
\begin_inset Formula $\mathcal{DL}$
\end_inset

, o lo que es lo mismo, en ontologías.
 Hay tres herramientas fundamentales, que desglosaremos luego, que usamos
 para buscar dichas simetrías.
\end_layout

\begin_layout Section
Las herramientas para 
\begin_inset Formula $\mathcal{ML}$
\end_inset


\end_layout

\begin_layout Standard
Explotaremos las herramientas que ya han sido desarrolladas para lógica
 modal.
 Si bien éstas fueron desarrolladas solo para lógica monomodal, se las adaptó
 para que funcionen para lógica multimodal.
\end_layout

\begin_layout Subsection
KCNF
\end_layout

\begin_layout Standard
Esta herramienta toma una fórmula modal escrita con formato 
\emph on
intohylo
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
https://hackage.haskell.org/package/hylolib-1.5.3/docs/HyLo-Formula.html
\end_layout

\end_inset

, y devuelve una fórmula, semánticamente igua, en forma conjuntiva normal.
\end_layout

\begin_layout Subsection
SY4NCL
\end_layout

\begin_layout Standard
Es una herramienta de línea de comando, desarrollada en Haskell, que toma
 una fórmula de la lógica modal básica en formato intohylo, construye el
 grafo seleccionado y lo disponibiliza en formato Bliss o Saucy, junto con
 un mapeo entre nodos y literales y estadísticas sobre el grafo.
 Por cada fórmula, generamos el correspondiente grafo usando sy4ncl.
 Luego, realizamos la búsqueda de automorfismos usando la herramienta Bliss
 
\begin_inset CommandInset citation
LatexCommand cite
key "Bliss"

\end_inset

.
\end_layout

\begin_layout Subsection
Bliss
\end_layout

\begin_layout Standard
Bliss toma la especificación de un grafo y retorna un conjunto de generadores
 para el grupo de automorfismos del grafo.
 Si el grafo tiene automorfismos no triviales, entonces reconstruimos las
 simetrías de la fórmula utilizando el mapeo entre nodos y literales generado
 por sy4ncl.
\end_layout

\begin_layout Section
Las herramientas para 
\begin_inset Formula $\mathcal{DL}$
\end_inset


\end_layout

\begin_layout Subsection
La API de OWL
\end_layout

\begin_layout Standard
Como ya vimos en el capítulo anterior, el lenguaje OWL es una extensión
 sintáctica de RDF.
 Hay mucha manipulación de strings URI y XML, por lo cual crear una simple
 ontología puede llegar a ser una tarea bastante tediosa.
 Por suerte, hay una herramienta escrita en 
\emph on
Java
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
https://www.java.com/
\end_layout

\end_inset


\emph default
 para escribir y procesar ontologías OWL, la 
\emph on
API
\emph default
 (
\emph on
Application Programming Interface
\emph default
, o Interfaz de programación de aplicaciones en español) de OWL
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://owlapi.sourceforge.net/
\end_layout

\end_inset

.
 Afortunadamente, también hay una implementación de la API de OWL en 
\emph on
Scala
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
https://www.scala-lang.org/
\end_layout

\end_inset


\emph default
, 
\emph on
Scowl
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://github.com/phenoscape/scowl
\end_layout

\end_inset

, el mismo lenguaje en el cual esta tesis está desarrollada.
\end_layout

\begin_layout Standard
En esta tesis utilizamos tanto la API de OWL como Scowl para manipular,
 y crear, ontologías.
\end_layout

\begin_layout Subsection
dl2ml
\end_layout

\begin_layout Standard
El proyecto del lado de 
\begin_inset Formula $\mathcal{DL}$
\end_inset

 está implementado en Scala, utilizando como librería principal a Scowl.
 Básicamente se toma una ontología como input, se obtienen los axiomas de
 interés y se traducen a fórmulas de 
\begin_inset Formula $\mathcal{ML}$
\end_inset

 siguiendo las traducciones que se han introducido en 
\begin_inset Note Greyedout
status collapsed

\begin_layout Plain Layout
FALTA REFERENCIA
\end_layout

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
FALTA REFERENCIA
\end_layout

\end_inset

.
 Por ejemplo, si nuestra ontología cuenta con los siguientes axiomas:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SubClassOf(padre ObjectIntersectionOf(persona ObjectSomeValuesFrom(tieneHijo
 persona)))
\end_layout

\begin_layout Plain Layout

ObjectPropertyRange(tieneHermano persona)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nuestro código tendrá como output:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

((A(padre --> (persona ^ (<tieneHijo>persona)));
\end_layout

\begin_layout Plain Layout

(A((<tieneHermano> true ) --> persona))
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Section
Scripts
\end_layout

\begin_layout Standard
Hay una serie de scripts que automatizan y facilitan el trabajo en general:
\end_layout

\begin_layout Itemize

\family typewriter
init.sh
\family default
:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
mkdirs.sh
\family default
: crea los directorios para las salidas de las herramientas sobre lógica
 modal
\end_layout

\begin_layout Itemize

\family typewriter
unzip.sh
\family default
: descomprime las ontologías sobre las que se buscarán simetrías
\end_layout

\begin_layout Itemize

\family typewriter
build.sh
\family default
: compila todas las herramientas para lógica modal
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
doall.sh:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
wipe.sh:
\family default
 borra datos previos de otras posibles corridas
\end_layout

\begin_layout Itemize

\family typewriter
sbt.sh
\family default
: se encarga de realizar las traducciones de todas las ontologías que encuentre
 en el directorio 
\family typewriter
ontologies/
\family default
 a lógica modal.
 También genera un mapeo entre variables proposicionales y los nombres de
 los conceptos
\end_layout

\begin_layout Itemize

\family typewriter
findsymm.sh
\family default
:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
k.sh
\family default
: todas las fórmulas en lógica modal que resolvió nuestro traductor, las
 pasa a formato CNF
\end_layout

\begin_layout Itemize

\family typewriter
s.sh
\family default
: genera los grafos
\end_layout

\begin_layout Itemize

\family typewriter
b.sh
\family default
: busca automorfismos en los grafos generados por el script anterior
\end_layout

\begin_layout Itemize

\family typewriter
bp.sh
\family default
: bliss-proc.py
\end_layout

\begin_layout Itemize

\family typewriter
map.sh
\family default
: mapea de vuelta las variables proposicionales a los nombres de los conceptos
 para una lectura más fácil de las simetrías encontradas
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Algunos scripts adicionales:
\end_layout

\begin_layout Itemize

\family typewriter
info.sh
\family default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Se encarga de generar archivos de información sobre las ontologías, como
 tamaño (MB), tbox count, abox count, etc.
 La información se guarda en 
\emph on
<dir>
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
generate_sheet.py
\family default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Genera un archivo con toda la información obtenida por los scripts, de forma
 estructurada.
\end_layout

\end_deeper
\begin_layout Subsection
Pipeline
\end_layout

\begin_layout Standard
Se puede correr 
\family typewriter
init.sh 
\family default
la primera vez y luego 
\family typewriter
doall.sh
\family default
 cuantas veces se quiera; lo importante es contar con los directorios creados,
 las herramientas para 
\begin_inset Formula $\mathcal{ML}$
\end_inset

 compiladas y ontologías sobre las cuales trabajar.
 Por lo tanto, una vez que se corre 
\family typewriter
init.sh 
\family default
se pueden remplazar todas las on
\end_layout

\end_body
\end_document
